" ═══════════════════════════════════════════════════════════════════════════
"" IdeaVim Configuration
"" Enhanced based on Neovim setup
"" Original config backed up to ~/.ideavimrc.backup
" ═══════════════════════════════════════════════════════════════════════════

" ═══════════════════════════════════════════════════════════════════════════
"" Leader Keys
" ═══════════════════════════════════════════════════════════════════════════
let mapleader = " "
let maplocalleader = " "

" ═══════════════════════════════════════════════════════════════════════════
"" Core Vim Settings
" ═══════════════════════════════════════════════════════════════════════════
set number                      " Show line numbers
set norelativenumber              " Show relative line numbers """" instead of doing it here in idea set hybrid
set ignorecase                  " Ignore case when searching
set smartcase                   " Override ignorecase if search has uppercase
set hlsearch                    " Highlight search results
set incsearch                   " Show search matches as you type
set scrolloff=7                 " Keep 7 lines visible above/below cursor
set clipboard=unnamedplus,unnamed,ideaput  " Use system clipboard
set showmode                    " Show current mode
set showcmd                     " Show command in status line
set visualbell                  " Use visual bell instead of beeping
set noerrorbells                " No error bells
set history=1000                " Command history size
set wrapscan                    " Searches wrap around end of file

" Indentation
set expandtab
set tabstop=2
set shiftwidth=2
set softtabstop=2
set smartindent

" Virtual edit in block mode
set virtualedit=block

" IdeaVim specific
set idearefactormode=keep       " Keep mode when refactoring
set ideajoin                    " Smart join
set ideamarks                   " Sync IJ bookmarks and Vim marks
set ideastatusicon=disabled     " Status icon (enabled, disabled, gray)


"" Choosing handlers in conflicting IDE/IdeaVim keymaps =======
sethandler <c-i> n-v-i:vim
sethandler <c-o> n-v-i:vim
sethandler <c-d> n-v-i:vim
sethandler <c-u> n-v-i:vim
sethandler <c-h> n-v-i:vim
sethandler <c-j> n-v-i:vim
sethandler <c-k> n-v-i:vim
sethandler <c-l> n-v-i:vim
sethandler <c-a-d> n-v-i:vim
sethandler <c-r> n-v-i:vim

" ═══════════════════════════════════════════════════════════════════════════
"" IdeaVim Extensions (Enable these in Settings)
" ═══════════════════════════════════════════════════════════════════════════
set surround                    " vim-surround: ys, cs, ds, S
set commentary                  " vim-commentary: gcc, gc + motion
set argtextobj                  " argument text objects: via, vaa, dia, daa
set textobj-entire              " entire buffer: vae, vie
set ReplaceWithRegister         " replace with register: gr, grr
set exchange                    " text exchange: cx, cxx, X, cxc
set highlightedyank             " highlight yanked text
set multiple-cursors            " multiple cursors: <A-n>, <A-x>, <A-p>
set which-key                   " which-key popup
set easymotion                  " easymotion navigation
set NERDTree                    " NERDTree file explorer
set matchit                     " extended % matching

set peekaboo                    " https://plugins.jetbrains.com/plugin/25776-vim-peekaboo
set dial                        " https://plugins.jetbrains.com/plugin/28237-vim-dial

" Which-key configuration
set notimeout
set timeoutlen=300
let g:WhichKey_ShowVimActions = "true"
let g:WhichKey_SortOrder = "by_key_prefix_first"
let g:WhichKey_KeyStyle = "bold"
let g:WhichKey_ShowTypedSequence = "true"
" close the popup and don't process formerly typed keys
let g:WhichKey_ProcessUnknownMappings = "false"

" Highlighted yank configuration
let g:highlightedyank_highlight_duration = "200"

"-- Toggle which-key plugin
let s:whichKeyEnabled = 0
function! WhichKeyToggle()
  if s:whichKeyEnabled
    set which-key!
    set notimeout!
    let s:whichKeyEnabled = 0
  else
    set which-key
    set notimeout
    let s:whichKeyEnabled = 1
  endif
endfunction

nmap <leader>8 :call WhichKeyToggle()<cr>
let g:WhichKeyDesc_toggle_which_key = "<leader>xw Toggle WhichKey"

function! toggleActionIds()
  "Track action IDs for easier mapping
  set trackactionids! 
endfunction

let g:WhichKeyDesc_toggle_action_ids = "<leader>xi Toggle actionIds"
nmap <leader>xi :call toggleActionIds()<cr>

function! toggleRelativeNumbers()
  "Toggle relative line numbers
  set relativenumber!
endfunction

let g:WhichKeyDesc_toggle_relative_numbers = "<leader>xn Toggle relative numbers"
nmap <leader>xn :call toggleRelativeNumbers()<cr>

" NerdTree
let g:NERDTreeMapActivateNode='l'
let g:NERDTreeMapJumpParent='h'
"nmap <C-1> :NERDTreeToggle<CR>

nnoremap <C-a> :DialIncrement<cr>
nnoremap <C-x> :DialDecrement<cr>

"-- Acejump plugin settings
let g:WhichKeyDesc_jump_kjump = "<leader><leader> jump"
map <leader><leader> <Action>(AceAction)
"nmap <leader><leader> <Action>(KJumpAction)
nmap S <Action>(AceBackwardAction)
nmap s <Action>(AceForwardAction)

let g:WhichKeyDesc_jump_word = "<leader>jw jump word"
nmap <leader>jw <Action>(KJumpAction.Word0)

let g:WhichKeyDesc_jump_line = "<leader>l jump line"
nmap <leader>l <Action>(KJumpAction.Line)

" Show usages
let g:WhichKeyDesc_usages = "<leader>* show usages"
map <leader>* <Action>(ShowUsages)

" ═══════════════════════════════════════════════════════════════════════════
"" Handler Configuration
" ═══════════════════════════════════════════════════════════════════════════
" Use vim handlers in normal mode and IDE handlers in insert mode
sethandler a:vim
sethandler <C-n> a:ide
sethandler <C-p> a:ide

" ═══════════════════════════════════════════════════════════════════════════
"" Basic Movements & Editing
" ═══════════════════════════════════════════════════════════════════════════
" Move by visual lines
nmap j gj
nmap k gk
vnoremap j gj
vnoremap k gk

" Center screen on navigation
nmap <C-d> <C-d>zz
nmap <C-u> <C-u>zz
nmap <C-f> <C-f>zz
nmap <C-b> <C-b>zz
nmap n nzz
nmap N Nzz
nmap * *zz
nmap # #zz
nmap <C-o> <C-o>zz
nmap <C-i> <C-i>zz

" Yank from cursor to end of line
nmap Y y$

" Save file
nmap <C-s> :w<CR>
inoremap <C-s> <Esc>:w<CR>
vnoremap <C-s> <Esc>:w<CR>

" Clear search highlighting
nmap <C-c> :nohlsearch<CR>
nmap ; :nohlsearch<CR>

" Disable F1
nmap <F1> <Esc>
inoremap <F1> <Esc>
vnoremap <F1> <Esc>

" Quick escape (like Neovim kj)
inoremap kj <Esc>
inoremap jj <Esc>

" Move highlighted region up and down
vnoremap J :m '>+1<CR>gv=gv
vnoremap K :m '<-2<CR>gv=gv


" Exit terminal mode
tnoremap <Esc><Esc> <C-\><C-n>

" Quick actions
map <C-space> <Action>(QuickActions)
map <A-j> <Action>(GotoAction)

" Spell suggestions
nmap z= <Action>(ShowIntentionActions)

" Better paste in visual mode (don't yank replaced text)
vnoremap <leader>p "_dP
vnoremap p pgvy


" ═══════════════════════════════════════════════════════════════════════════
"" Navigation and Window Management
" ═══════════════════════════════════════════════════════════════════════════

" Navigate back/forward
map gb <Action>(Back)
map gf <Action>(Forward)
map <A-Left> <Action>(Back)
map <A-Right> <Action>(Forward)

nmap <C-h> <C-w>h
nmap <C-j> <C-w>j
nmap <C-k> <C-w>k
nmap <C-l> <C-w>l

map <C-w>j <Action>(Unsplit)
map <C-w>n <Action>(EditSourceInNewWindow)

" Resize splits
map <A-,> <Action>(StretchSplitToLeft)
map <A-.> <Action>(StretchSplitToRight)
map <A-s-,> <Action>(StretchSplitToTop)
map <A-s-.> <Action>(StretchSplitToBottom)
map <A-z> <Action>(MaximizeEditorInSplit)
map <C-w>z <Action>(MaximizeEditorInSplit)

" Folds
nmap - <Action>(ExpandAllRegions)
nmap za <Action>(ExpandCollapseToggleAction)

" ═══════════════════════════════════════════════════════════════════════════
"" AI
" ═══════════════════════════════════════════════════════════════════════════
let g:WhichKeyDesc_ai = "<leader>a +AI"
nmap <leader>ac <Action>(ActivateGitHubCopilotChatToolWindow)
nmap <leader>ai <Action>(copilot.chat.inline)


" ═══════════════════════════════════════════════════════════════════════════
" Diagnostics/Debug
" ══════════════════════════════════════════════════════════════════════════
let g:WhichKeyDesc_diagnostics = "<leader>d +diagnostics"

" Navigate diagnostics/errors
nmap ]d <Action>(GotoNextError)
nmap [d <Action>(GotoPreviousError)
nmap ]e <Action>(GotoNextError)
nmap [e <Action>(GotoPreviousError)

let g:WhichKeyDesc_lsp_diagnostics = "<leader>dd document"
nmap <leader>dd <Action>(ActivateProblemsViewToolWindow)

let g:WhichKeyDesc_diagnostics_line = "<leader>dl line error"
nmap <leader>dl <Action>(ShowErrorDescription)

let g:WhichKeyDesc_diagnostics_next = "<leader>dn next"
nmap <leader>dn <Action>(GotoNextError)

let g:WhichKeyDesc_diagnostics_previous = "<leader>dp previous"
nmap <leader>dp <Action>(GotoPreviousError)

let g:WhichKeyDesc_diagnostics_workspace = "<leader>dw workspace"
nmap <leader>dw <Action>(ActivateProblemsViewToolWindow)

" ═══════════════════════════════════════════════════════════════════════════
"" Goto Actions (<leader>g)
" ═══════════════════════════════════════════════════════════════════════════

nmap gd <Action>(GotoDeclaration)
nmap gD <Action>(GotoDeclaration)
nmap gI <Action>(GotoImplementation)
nmap gy <Action>(GotoTypeDeclaration)
nmap gr <Action>(FindUsages)

let g:WhichKeyDesc_goto = "<leader>g +goto"

let g:WhichKeyDesc_goto_block_start = "<leader>g[ block start"
map <leader>g[ <Action>(EditorCodeBlockStart)

let g:WhichKeyDesc_goto_block_end = "<leader>g] block end"
map <leader>g] <Action>(EditorCodeBlockEnd)

let g:WhichKeyDesc_goto_action = "<leader>ga action"
nmap <leader>ga <Action>(GotoAction)

let g:WhichKeyDesc_goto_class = "<leader>gc class"
nmap <leader>gc <Action>(GotoClass)

let g:WhichKeyDesc_goto_call_hierarchy = "<leader>gC call hierarchy"
nmap <leader>gC <Action>(CallHierarchy)

let g:WhichKeyDesc_goto_definition = "<leader>gd definition"
nmap <leader>gd <Action>(GotoDeclaration)

let g:WhichKeyDesc_goto_files = "<leader>gf find files"
map <leader>gf <Action>(GotoFile)

let g:WhichKeyDesc_goto_project_view = "<leader>gg project view"
nmap <leader>gg <Action>(SelectInProjectView)

let g:WhichKeyDesc_goto_type_hierarchy = "<leader>gH type hierarchy"
nmap <leader>gH <Action>(TypeHierarchy)

let g:WhichKeyDesc_goto_implementation = "<leader>gi implementation"
nmap <leader>gi <Action>(GotoImplementation)

let g:WhichKeyDesc_goto_quick_implementation = "<leader>gI quick implementations"
nmap <leader>gI <Action>(QuickImplementations)


let g:WhichKeyDesc_view_signature = "<leader>gq quick signature"
map <leader>gq <Action>(QuickTypeDefinition)

let g:WhichKeyDesc_goto_recent_locations_popup = "<leader>gl recent locations"
nmap <leader>gl <Action>(RecentLocations)

let g:WhichKeyDesc_goto_marks = "<leader>gm marks"
nmap <leader>gm <Action>(ShowBookmarks)

let g:WhichKeyDesc_goto_usages_popup = "<leader>gr usages popup"
nmap <leader>gr <Action>(ShowUsages)

let g:WhichKeyDesc_goto_references = "<leader>gR references"
nmap <leader>gR <Action>(FindUsages)

let g:WhichKeyDesc_goto_symbol = "<leader>gs symbol"
nmap <leader>gs <Action>(GotoSymbol)

let g:WhichKeyDesc_goto_super = "<leader>gS super method"
nmap <leader>gS <Action>(GotoSuperMethod)

let g:WhichKeyDesc_goto_type_definition = "<leader>gt type definition"
nmap <leader>gt <Action>(GotoTypeDeclaration)

let g:WhichKeyDesc_goto_test = "<leader>gT test"
nmap <leader>gT <Action>(GotoTest)

let g:WhichKeyDesc_goto_usages = "<leader>gu usages"
nmap <leader>gu <Action>(FindUsages)

let g:WhichKeyDesc_goto_structure = "<leader>gv structure"
nmap <leader>gv <Action>(FileStructurePopup)

let g:WhichKeyDesc_goto_related = "<leader>gx related"
nmap <leader>gx <Action>(GotoRelated)


" ═══════════════════════════════════════════════════════════════════════════
" Harpoon
" ═══════════════════════════════════════════════════════════════════════════
let g:WhichKeyDesc_bookmarks = "<leader>h +harpoon"
let g:WhichKeyDesc_bookmarks_show = "<leader>hh show"
map <leader>hh <Action>(ShowBookmarks)
let g:WhichKeyDesc_bookmarks_show = "<leader>ht show tool window"
map <leader>ht <Action>(ActivateBookmarksToolWindow)

map <leader>hr <Action>(EditBookmark)
map <leader>hc <Action>(ToggleBookmarkWithMnemonic)
map <leader>hd <Action>(ToggleBookmark)

let g:WhichKeyDesc_bookmarks_next = "<leader>'f next bookmark"
map <leader>hf <Action>(GotoNextBookmark)

let g:WhichKeyDesc_bookmarks_prev = "<leader>'b prev bookmark"
map <leader>hb <Action>(GotoPreviousBookmark)

" Mnemonic bookmarks (m0-m9, ma-mz to toggle, '0-'9, 'a-'z to goto)
map m0 <Action>(ToggleBookmark0)
map m1 <Action>(ToggleBookmark1)
map m2 <Action>(ToggleBookmark2)
map m3 <Action>(ToggleBookmark3)
map m4 <Action>(ToggleBookmark4)
map m5 <Action>(ToggleBookmark5)
map m6 <Action>(ToggleBookmark6)
map m7 <Action>(ToggleBookmark7)
map m8 <Action>(ToggleBookmark8)
map m9 <Action>(ToggleBookmark9)
map ma <Action>(ToggleBookmarkA)
map mb <Action>(ToggleBookmarkB)
map mc <Action>(ToggleBookmarkC)
map md <Action>(ToggleBookmarkD)
map me <Action>(ToggleBookmarkE)
map mf <Action>(ToggleBookmarkF)
map mg <Action>(ToggleBookmarkG)
map mh <Action>(ToggleBookmarkH)
map mi <Action>(ToggleBookmarkI)
map mj <Action>(ToggleBookmarkJ)
map mk <Action>(ToggleBookmarkK)
map ml <Action>(ToggleBookmarkL)
map mm <Action>(ToggleBookmarkM)
map mn <Action>(ToggleBookmarkN)
map mo <Action>(ToggleBookmarkO)
map mp <Action>(ToggleBookmarkP)
map mq <Action>(ToggleBookmarkQ)
map mr <Action>(ToggleBookmarkR)
map ms <Action>(ToggleBookmarkS)
map mt <Action>(ToggleBookmarkT)
map mu <Action>(ToggleBookmarkU)
map mv <Action>(ToggleBookmarkV)
map mw <Action>(ToggleBookmarkW)
map mx <Action>(ToggleBookmarkX)
map my <Action>(ToggleBookmarkY)
map mz <Action>(ToggleBookmarkZ)
map '0 <Action>(GotoBookmark0)
map '1 <Action>(GotoBookmark1)
map '2 <Action>(GotoBookmark2)
map '3 <Action>(GotoBookmark3)
map '4 <Action>(GotoBookmark4)
map '5 <Action>(GotoBookmark5)
map '6 <Action>(GotoBookmark6)
map '7 <Action>(GotoBookmark7)
map '8 <Action>(GotoBookmark8)
map '9 <Action>(GotoBookmark9)
map 'a <Action>(GotoBookmarkA)
map 'b <Action>(GotoBookmarkB)
map 'c <Action>(GotoBookmarkC)
map 'd <Action>(GotoBookmarkD)
map 'e <Action>(GotoBookmarkE)
map 'f <Action>(GotoBookmarkF)
map 'g <Action>(GotoBookmarkG)
map 'h <Action>(GotoBookmarkH)
map 'i <Action>(GotoBookmarkI)
map 'j <Action>(GotoBookmarkJ)
map 'k <Action>(GotoBookmarkK)
map 'l <Action>(GotoBookmarkL)
map 'm <Action>(GotoBookmarkM)
map 'n <Action>(GotoBookmarkN)
map 'o <Action>(GotoBookmarkO)
map 'p <Action>(GotoBookmarkP)
map 'q <Action>(GotoBookmarkQ)
map 'r <Action>(GotoBookmarkR)
map 's <Action>(GotoBookmarkS)
map 't <Action>(GotoBookmarkT)
map 'u <Action>(GotoBookmarkU)
map 'v <Action>(GotoBookmarkV)
map 'w <Action>(GotoBookmarkW)
map 'x <Action>(GotoBookmarkX)
map 'y <Action>(GotoBookmarkY)
map 'z <Action>(GotoBookmarkZ)

" ═══════════════════════════════════════════════════════════════════════════
"" Caret/Multi-cursor
" ═══════════════════════════════════════════════════════════════════════════
let g:WhichKeyDesc_caret = "<leader>k +caret/multicursor"

let g:WhichKeyDesc_caret_add = "<leader>ka add"
vmap <leader>ka <Action>(EditorAddCaretPerSelectedLine)
nmap <leader>ka <Action>(EditorCloneCaretBelow)

let g:WhichKeyDesc_caret_next = "<leader>kn next occurrence"
map <leader>kn <Action>(SelectNextOccurrence)

let g:WhichKeyDesc_caret_all = "<leader>ko all occurrences"
map <leader>ko <Action>(SelectAllOccurrences)

let g:WhichKeyDesc_caret_unselect = "<leader>ku unselect occurrence"
map <leader>ku <Action>(UnselectPreviousOccurrence)

" ═══════════════════════════════════════════════════════════════════════════
" LSP
" ═══════════════════════════════════════════════════════════════════════════

" Navigate methods
map [[ <Action>(MethodUp)
map ]] <Action>(MethodDown)

let g:WhichKeyDesc_l = "<leader>l +LSP"
let g:WhichKeyDesc_lsp_format = "<leader>= format"
map <leader>= <Action>(ReformatCode)

" K for type/hover info in visual mode
vnoremap K <Action>(Scala.TypeInfo)

" K for hover info in normal mode
nmap K <Action>(QuickJavaDoc)

" Ctrl-K for signature help in insert mode
inoremap <C-k> <C-o><Action>(ParameterInfo)

" H for signature help in normal mode
nmap H <Action>(ParameterInfo)
nmap Q <Action>(QuickImplementations)

nmap <M-CR> <Action>(ShowIntentionActions)
vnoremap <M-CR> <Action>(ShowIntentionActions)

" Compile
let g:WhichKeyDesc_lc = "<leader>lc +compile"

let g:WhichKeyDesc_lsp_compile_compile = "<leader>lcc compile"
map <leader>lcc <Action>(Compile)

let g:WhichKeyDesc_lsp_compile_dirty = "<leader>lcd compile dirty"
map <leader>lcd <Action>(CompileDirty)

let g:WhichKeyDesc_lsp_compile_file = "<leader>lcf compile file"
map <leader>lcf <Action>(CompileFile)

let g:WhichKeyDesc_lsp_compile_project = "<leader>lcp compile project"
map <leader>lcp <Action>(CompileProject)

" Debug/Run
let g:WhichKeyDesc_lsp_diagnostics = "<leader>ld +debug"

let g:WhichKeyDesc_run_debug = "<leader>rd debug"
nmap <leader>rd <Action>(Debug)

let g:WhichKeyDesc_lsp_debug_failed = "<leader>ldf run failed tests"
map <leader>ldf <Action>(RerunFailedTests)

let g:WhichKeyDesc_lsp_debug_last = "<leader>ldl run last"
map <leader>ldl <Action>(Run)

let g:WhichKeyDesc_lsp_debug_run = "<leader>ldr run class"
map <leader>ldr <Action>(RunClass)

let g:WhichKeyDesc_buffer_breakpoint = "<leader>ldb toggle breakpoint"
nmap <leader>ldb <Action>(ToggleLineBreakpoint)

let g:WhichKeyDesc_buffer_eval = "<leader>le evaluate expression"
nmap <leader>le <Action>(EvaluateExpression)

let g:WhichKeyDesc_lsp_debug_viewbreakpoints = "<leader>ldv view breakpoints"
nmap <leader>ldv <Action>(ViewBreakpoints)

let g:WhichKeyDesc_lsp_hierarchy = "<leader>lh hierarchy"
nmap <leader>lh <Action>(TypeHierarchy)

let g:WhichKeyDesc_lsp_incoming_calls = "<leader>li incoming calls"
nmap <leader>li <Action>(CallHierarchy)

let g:WhichKeyDesc_lsp_organize_imports = "<leader>lo organize imports"
nmap <leader>lo <Action>(OptimizeImports)

" Scala
let g:WhichKeyDesc_ls = "<leader>lm +scala"

let g:WhichKeyDesc_lsp_scala_console = "<leader>lC scala console"
nmap <leader>lmC <Action>(Scala.RunConsole)

let g:WhichKeyDesc_action_configure_hints = "<leader>ac configure type hints"
map <leader>lmc <Action>(Scala.ConfigureTypeHints)

let g:WhichKeyDesc_show_desugar = "<leader>lmd desugar"
map <leader>lmd <Action>(Scala.Desugar)

let g:WhichKeyDesc_lsp_make_explicit = "<leader>lme make explicit"
map <leader>lme <Action>(Scala.MakeExplicit)

let g:WhichKeyDesc_toggle_exclusive = "<leader>lmE toggle exclusive hint"
map <leader>lmE <Action>(Scala.ToggleRangeExclusiveHintAction)

let g:WhichKeyDesc_toggle_inlay = "<leader>lmh toggle inlay hints"
map <leader>lmh <Action>(Scala.ToggleMethodChainInlayHints)

let g:WhichKeyDesc_toggle_hints = "<leader>lmH toggle hints"
map <leader>lmH <Action>(Scala.ToggleRangeHintsForToAndUntilAction)

let g:WhichKeyDesc_show_decompile = "<leader>lmj decompile to java"
map <leader>lmj <Action>(Scala.DecompileToJava)

let g:WhichKeyDesc_lsp_sbt_run_command = "<leader>lmr sbt run command"
nmap <leader>lmr <Action>(Scala.Sbt.RunCommand)

let g:WhichKeyDesc_lsp_sbt_run_task = "<leader>lmt sbt run task"
nmap <leader>lmt <Action>(Scala.Sbt.RunTask)

let g:WhichKeyDesc_lsp_sbt_show_task = "<leader>lmT sbt show task"
nmap <leader>lmT <Action>(Scala.Sbt.ShowTask)

let g:WhichKeyDesc_tests = "<leader>lt tests"

let g:WhichKeyDesc_run_recent_tests = "<leader>ltr recent tests"
nmap <leader>ltr <Action>(ShowRecentTests)

" implicits
let g:WhichKeyDesc_view_implicit = "<leader>lmi +implicits"

let g:WhichKeyDesc_view_implicit_args = "<leader>lmia args"
map <leader>lmia <Action>(Scala.ShowImplicitArguments)

let g:WhichKeyDesc_view_implicit_conv = "<leader>lmic conversions"
map <leader>lmic <Action>(Scala.ShowImplicitConversions)

let g:WhichKeyDesc_view_implicit_expand = "<leader>lmie expand"
map <leader>lmie <Action>(Scala.ExpandImplicits)

let g:WhichKeyDesc_view_implicit_show = "<leader>lmis show"
map <leader>lmis <Action>(Scala.ShowImplicits)


let g:WhichKeyDesc_lsp_worksheet_alt = "<leader>lmw worksheet"
nmap <leader>lmw <Action>(Scala.RunWorksheet)

" ═══════════════════════════════════════════════════════════════════════════
" Refactorings
" ═══════════════════════════════════════════════════════════════════════════
"
let g:WhichKeyDesc_extract = "<leader>r +refactor"

let g:WhichKeyDesc_refactor_delete = "<leader>rD safe delete"
nmap <leader>rD <Action>(SafeDelete)

let g:WhichKeyDesc_refactor_inline = "<leader>ri inline"
map <leader>ri <Action>(Inline)

let g:WhichKeyDesc_refactor_java_scala = "<leader>rj rename java to scala"
map <leader>rj <Action>(Scala.RenameJavaToScala)

let g:WhichKeyDesc_refactor_overide = "<leader>rro override methods"
map <leader>ro <Action>(OverrideMethods)

let g:WhichKeyDesc_refactor_parameter = "<leader>rp introduce parameter"
map <leader>rp <Action>(IntroduceParameter)

let g:WhichKeyDesc_refactor_quicklist = "<leader>rq refactor menu"
map <leader>rq <Action>(Refactorings.QuickListPopupAction)

let g:WhichKeyDesc_refactor_rename = "<leader>rr rename"
map <leader>rr <Action>(RenameElement)

let g:WhichKeyDesc_refactor_signature = "<leader>rS change signature"
nmap <leader>rs <Action>(ChangeSignature)

let g:WhichKeyDesc_refactor_variable = "<leader>rv introduce variable"
map <leader>rv <Action>(IntroduceVariable)

let g:WhichKeyDesc_refactor_whitespace = "<leader>rw remove whitespace"
nmap <leader>rw :%s/\s\+$<CR>
vmap <leader>rw <Esc>:%s/\s\+$<CR>


" =================================
" Extract
" =================================
let g:WhichKeyDesc_extract = "<leader>re +extract"

let g:WhichKeyDesc_extract_class = "<leader>rec class"
map <leader>rec <Action>(ExtractClass)

let g:WhichKeyDesc_extract_function = "<leader>ref function"
map <leader>ref <Action>(ExtractFunction)

let g:WhichKeyDesc_extract_interface = "<leader>rei interface"
nmap <leader>rei <Action>(ExtractInterface)

let g:WhichKeyDesc_extract_method = "<leader>rem method"
map <leader>rem <Action>(ExtractMethod)

let g:WhichKeyDesc_extract_scope = "<leader>res to scope"
map <leader>res <Action>(ExtractFunctionToScope)

let g:WhichKeyDesc_extract_trait = "<leader>ret trait"
map <leader>ret <Action>(Scala.ExtractTrait)

let g:WhichKeyDesc_extract_superclass = "<leader>reu superclass"
nmap <leader>reu <Action>(ExtractSuperclass)

let g:WhichKeyDesc_extract_window = "<leader>rew extract window"
map <leader>rew <Action>(ExtractMethodToolWindow.TreePopup)

" =================================
" Generate
" =================================
let g:WhichKeyDesc_generate = "<leader>rg +generate"

let g:WhichKeyDesc_generate_companion = "<leader>rgc companion object"
map <leader>rgc <Action>(Scala.GenerateCompanionObject)

let g:WhichKeyDesc_generate_doc = "<leader>rgd scaladoc"
map <leader>rgd <Action>(Scala.GenerateScaladoc)

let g:WhichKeyDesc_new_doc = "<leader>rgD new doc stub"
map <leader>rgD <Action>(Scala.CreateScalaDocStub)

let g:WhichKeyDesc_generate_equals = "<leader>rge equals"
map <leader>rge <Action>(Scala.GenerateEquals)

let g:WhichKeyDesc_code_generate = "<leader>rgg generate"
map <leader>rgg <Action>(Generate)

let g:WhichKeyDesc_generate_property = "<leader>rgp property"
map <leader>rgp <Action>(Scala.GenerateProperty)

let g:WhichKeyDesc_new_package = "<leader>rgP package object"
map <leader>rgP <Action>(Scala.NewPackageObject)

let g:WhichKeyDesc_generate_tostring = "<leader>rgs toString"
map <leader>rgs <Action>(Scala.GenerateToString)

let g:WhichKeyDesc_new_class = "<leader>rgn new class"
map <leader>rgn <Action>(Scala.NewClass)

let g:WhichKeyDesc_lsp_create_worksheet = "<leader>rgw light worksheet"
map <leader>rgw <Action>(Scala.CreateLightWorksheetAction)

let g:WhichKeyDesc_new_worksheet = "<leader>rgW worksheet"
map <leader>rgW <Action>(Scala.NewScalaWorksheet)


" ═══════════════════════════════════════════════════════════════════════════
"" Git / Changes
" ═══════════════════════════════════════════════════════════════════════════

" Navigate changes
map g; <Action>(JumpToLastChange)
map g, <Action>(JumpToNextChange)

" Git hunks navigation
nmap ]g <Action>(VcsShowNextChangeMarker)
nmap [g <Action>(VcsShowPrevChangeMarker)

let g:WhichKeyDesc_git = "<leader>m +git"

let g:WhichKeyDesc_git_add = "<leader>ma add"
"nmap <leader>ma <Action>(Git.Add)
nmap <leader>mha <Action>(Git.Stage.Add)
"nmap <leader>ma <Action>(ChangesView.AddUnversioned)

let g:WhichKeyDesc_git_branches = "<leader>mB branches"
nmap <leader>mb <Action>(Git.Branches)

let g:WhichKeyDesc_git_commit = "<leader>mc commit"
map <leader>mc <Action>(Git.Commit.Stage)

let g:WhichKeyDesc_git_compare_branch = "<leader>mC compare with branch"
nmap <leader>mC <Action>(Git.CompareWithBranch)

let g:WhichKeyDesc_git_diff = "<leader>md diff/status"
map <leader>md <Action>(Vcs.Show.Local.Changes)

let g:WhichKeyDesc_git_fetch = "<leader>mf fetch"
map <leader>mf <Action>(Git.Fetch)

let g:WhichKeyDesc_git_fuzzy_files = "<leader>mg fuzzy git files"
map <leader>mg <Action>(Vcs.QuickListPopupAction)

let g:WhichKeyDesc_git_buffer_commits = "<leader>mH buffer commits"
map <leader>mH <Action>(Vcs.ShowTabbedFileHistory)

"let g:WhichKeyDesc_git_history = "<leader>mh history"
"map <leader>mh <Action>(Vcs.ShowHistoryForBlock)

let g:WhichKeyDesc_git_hunk = "<leader>mh hunk"

let g:WhichKeyDesc_git_hunk_next = "<leader>mhn next hunk"
nmap <leader>mhn <Action>(VcsShowNextChangeMarker)

let g:WhichKeyDesc_git_hunk_prev = "<leader>mhp prev hunk"
nmap <leader>mhp <Action>(VcsShowPrevChangeMarker)

let g:WhichKeyDesc_git_hunk_rollback = "<leader>mhR rollback hunk"
map <leader>mhR <Action>(Vcs.RollbackChangedLines)

let g:WhichKeyDesc_git_hunk_preview = "<leader>mhv preview hunk"
nmap <leader>mhv <Action>(VcsShowCurrentChangeMarker)

let g:WhichKeyDesc_git_menu = "<leader>mm menu"
map <leader>mm <Action>(Git.Menu)

let g:WhichKeyDesc_git_log = "<leader>ml log"
map <leader>ml <Action>(Git.Log)

map <leader>mo <Action>(uk.co.ben_gibson.git.link.ui.actions.menu.BrowserAction)

let g:WhichKeyDesc_git_pull = "<leader>mp pull"
map <leader>mp <Action>(Git.Pull)

let g:WhichKeyDesc_git_stash = "<leader>ms stash"
map <leader>ms <Action>(Git.Stash)

let g:WhichKeyDesc_git_stash_list = "<leader>mS stash list"
map <leader>mS <Action>(Git.Stash)

let g:WhichKeyDesc_git_unstash = "<leader>mu unstash"
map <leader>mu <Action>(Git.Unstash)

let g:WhichKeyDesc_git_blame = "<leader>mv blame"
map <leader>mv <Action>(Annotate)

let g:WhichKeyDesc_git_workspace = "<leader>mw workspace changes"
map <leader>mw <Action>(Vcs.Show.Local.Changes)

map <leader>my <Action>(uk.co.ben_gibson.git.link.ui.actions.menu.CopyAction)

" ═══════════════════════════════════════════════════════════════════════════
"" Search
" ═══════════════════════════════════════════════════════════════════════════

map * <Action>(FindWordAtCaret)

let g:WhichKeyDesc_search = "<leader>s +search"

let g:WhichKeyDesc_search_continue = "<leader>sc continue"
map <leader>sc <Action>(FindInPath)

let g:WhichKeyDesc_search_fuzzy_files = "<leader>sf fuzzy files"
map <leader>sf <Action>(GotoFile)

let g:WhichKeyDesc_search_file_usages = "<leader>sF usages in file"
nmap <leader>sF <Action>(FindUsagesInFile)

let g:WhichKeyDesc_search_highlight = "<leader>sh highlight"
map <leader>sh <Action>(HighlightUsagesInFile)

let g:WhichKeyDesc_search_menu = "<leader>sm usages menu"
map <leader>sm <Action>(FindUsagesMenuGroup)

let g:WhichKeyDesc_search_path = "<leader>sp find in path"
map <leader>sp <Action>(FindInPath)

let g:WhichKeyDesc_search_grep = "<leader>ss search"
map <leader>ss <Action>(FindInPath)

let g:WhichKeyDesc_search_find = "<leader>sS find"
map <leader>sS <Action>(Find)

let g:WhichKeyDesc_search_usages = "<leader>su usages"
map <leader>su <Action>(FindUsages)

let g:WhichKeyDesc_search_visual = "<leader>sv find selection"
map <leader>sv <Action>(FindSelectionInPath)

let g:WhichKeyDesc_search_window = "<leader>sw find window"
map <leader>sw <Action>(ActivateFindToolWindow)


" ═══════════════════════════════════════════════════════════════════════════
" Tab Management
" ═══════════════════════════════════════════════════════════════════════════
map <C-s-tab> <Action>(NextTab)
map <C-tab> <Action>(PreviousTab)

let g:WhichKeyDesc_tabs = "<leader>t +tabs"

let g:WhichKeyDesc_tab_changes = "<leader>tc recent changes"
map <leader>tc <Action>(RecentChangedFiles)

let g:WhichKeyDesc_tab_structure = "<leader>tf structure"
map <leader>tf <Action>(FileStructurePopup)

let g:WhichKeyDesc_tab_prev = "<leader>th previous"
map <leader>th <Action>(PreviousTab)

let g:WhichKeyDesc_tab_next = "<leader>tl next"
map <leader>tl <Action>(NextTab)

let g:WhichKeyDesc_tab_move = "<leader>tm move opposite"
map <leader>tm <Action>(MoveEditorToOppositeTabGroup)

let g:WhichKeyDesc_tab_next_short = "<leader>tn next"
nmap <leader>tn <Action>(NextTab)

let g:WhichKeyDesc_tab_old_files = "<leader>to old files"
map <leader>to <Action>(RecentFiles)

let g:WhichKeyDesc_tab_orientation = "<leader>tO orientation"
map <leader>tO <Action>(ChangeSplitOrientation)

let g:WhichKeyDesc_tab_prev_short = "<leader>tp previous"
nmap <leader>tp <Action>(PreviousTab)

let g:WhichKeyDesc_tab_recent = "<leader>tr recent"
map <leader>tr <Action>(RecentFiles)

let g:WhichKeyDesc_tab_switcher = "<leader>ts switcher"
map <leader>ts <Action>(Switcher)

let g:WhichKeyDesc_tab_last = "<leader>tt last"
map <leader>tt <Action>(VimFilePrevious)

"let g:WhichKeyDesc_tab_reopen = "<leader>tu reopen"
"map <leader>tu <Action>(ReopenClosedTab)

let g:WhichKeyDesc_tab_unsplit = "<leader>tu unsplit"
nmap <leader>tu <Action>(Unsplit)
let g:WhichKeyDesc_tab_unsplit_all = "<leader>tU unsplit all"
nmap <leader>tU <Action>(UnsplitAll)

let g:WhichKeyDesc_tab_yank = "<leader>ty open opposite"
map <leader>ty <Action>(OpenEditorInOppositeTabGroup)

let g:WhichKeyDesc_last_tab = "<leader><Tab> last tab"
nmap <leader><tab> <Action>(GoToLastTab)


" ═══════════════════════════════════════════════════════════════════════════
"" TODO
" ═══════════════════════════════════════════════════════════════════════════
let g:WhichKeyDesc_editor_eval = "<leader>ee evaluate"
map <leader>ee <Action>(EvaluateExpression)

let g:WhichKeyDesc_editor_snippet = "<leader>el live template"
map <leader>el <Action>(InsertLiveTemplate)

let g:WhichKeyDesc_editor_type = "<leader>et expression type"
map <leader>et <Action>(ExpressionTypeInfo)

let g:WhichKeyDesc_file_new = "<leader>fN new file"
map <leader>fN <Action>(NewFile)

let g:WhichKeyDesc_file_rename = "<leader>fR rename"
map <leader>fR <Action>(RenameFile)

let g:WhichKeyDesc_file_copy_path = "<leader>fy copy path"
map <leader>fy <Action>(CopyPaths)

let g:WhichKeyDesc_goto_help = "<leader>gh help"
nmap <leader>gh <Action>(SearchEverywhere)


let g:WhichKeyDesc_view_hints = "<leader>lvh toggle inlay hints"
map <leader>lvs <Action>(FileStructurePopup)

let g:WhichKeyDesc_view_hints = "<leader>lvh toggle inlay hints"
map <leader>lvh <Action>(ToggleInlayHintsGloballyAction)


let g:WhichKeyDesc_project_close = "<leader>qq close project"
map <leader>qq <Action>(CloseProject)

let g:WhichKeyDesc_project_exit = "<leader>qQ exit"
map <leader>qQ <Action>(Exit)

let g:WhichKeyDesc_project_close_other = "<leader>qO close other"
map <leader>qO <Action>(CloseOtherProjects)

let g:WhichKeyDesc_project_recent = "<leader>qr recent projects"
map <leader>qr <Action>(RecentProjectListGroup)

let g:WhichKeyDesc_config_hints = "<leader>vh type hints"
map <leader>vh <Action>(ToggleTypeHints)

let g:WhichKeyDesc_view_mainmenu = "<leader>vm main menu"
map <leader>vm <Action>(ViewMenu)

let g:WhichKeyDesc_config_settings = "<leader>vs settings"
map <leader>vs <Action>(ShowSettings)

let g:WhichKeyDesc_config_ui = "<leader>vu ui toggle"
map <leader>vu <Action>(UIToggleActions)

" Hover and signature help (like Neovim)
map <A-h> <Action>(ShowHoverInfo)


" ═══════════════════════════════════════════════════════════════════════════
"" Window Actions (<leader>w)
" ═══════════════════════════════════════════════════════════════════════════
let g:WhichKeyDesc_window_unsplit_all = "<leader>wa unsplit all"
map <leader>wa <Action>(UnsplitAll)

let g:WhichKeyDesc_window_close = "<leader>wc close"
map <leader>wc <Action>(CloseContent)

let g:WhichKeyDesc_window_only = "<leader>wo close others"
map <leader>wo <Action>(CloseAllEditorsButActive)

let g:WhichKeyDesc_window_hsplit = "<leader>ws split horizontal"
map <leader>ws <Action>(SplitHorizontally)

let g:WhichKeyDesc_window_unsplit = "<leader>wu unsplit"
map <leader>wu <Action>(Unsplit)

let g:WhichKeyDesc_window_vsplit = "<leader>wv split vertical"
map <leader>wv <Action>(SplitVertically)


" ═══════════════════════════════════════════════════════════════════════════
"" Zen Actions (<leader>z)
" ═══════════════════════════════════════════════════════════════════════════
let g:WhichKeyDesc_zen_hide_all = "<leader>z hide all windows"
map <A-c> <Action>(HideAllWindows)
map <leader>z <Action>(HideAllWindows)

" Switcher
map <C-2> <Action>(Switcher)

" Font size
map <C-S-=> <Action>(EditorIncreaseFontSize)
map <C-=> <Action>(EditorResetFontSize)
map <C--> <Action>(EditorDecreaseFontSize)


" ═══════════════════════════════════════════════════════════════════════════
"" Misc Actions
" ═══════════════════════════════════════════════════════════════════════════
let g:WhichKeyDesc_misc_activity = "<leader>xa activity monitor"
map <leader>xa <Action>(Performance.ActivityMonitor)

let g:WhichKeyDesc_misc_distraction = "<leader>xd distraction free"
map <leader>xd <Action>(ToggleDistractionFreeMode)

let g:WhichKeyDesc_misc_reveal = "<leader>xf reveal in file manager"
map <leader>xf <Action>(RevealIn)

let g:WhichKeyDesc_misc_wrap = "<leader>xg toggle soft wrap"
map <leader>xg <Action>(EditorGutterToggleGlobalSoftWraps)

let g:WhichKeyDesc_action_invalidate_cache = "<leader>xI invalidate caches"
map <leader>xI <Action>(InvalidateCaches)

let g:WhichKeyDesc_misc_keybindings = "<leader>xk show keybindings"
nmap <leader>xk :map<CR>

" Toggle line number relative
function! NumberToggle()
  if(&relativenumber == 1)
    set norelativenumber
  else
    set relativenumber number
  endif
endfunction

let g:WhichKeyDesc_window_number_toggle = "<leader>xn toggle line numbers"
nmap <leader>xn :call NumberToggle()<cr>

let g:WhichKeyDesc_misc_notifications = "<leader>xN mark notifications read"
map <leader>xN <Action>(MarkNotificationsAsRead)

let g:WhichKeyDesc_misc_open = "<leader>xp open file"
map <leader>xp <Action>(OpenFile)

let g:WhichKeyDesc_misc_reveal_choose = "<leader>xr reveal choose"
map <leader>xr <Action>(RevealGroup)

let g:WhichKeyDesc_misc_reload = "<leader>xR reload vimrc"
nmap <leader>xR :source ~/.ideavimrc<CR>

let g:WhichKeyDesc_misc_saul = "<leader>xs call saul"
map <leader>xs <Action>(CallSaul)

let g:WhichKeyDesc_config_editor = "<leader>xt edito toggle actions"
map <leader>xt <Action>(EditorToggleActions)

let g:WhichKeyDesc_misc_zen = "<leader>xz zen mode"
map <leader>xz <Action>(ToggleZenMode)

" ═══════════════════════════════════════════════════════════════════════════
"" Bookmarks
" ═══════════════════════════════════════════════════════════════════════════


